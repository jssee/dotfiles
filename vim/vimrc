if &compatible
  set nocompatible
endif

packadd minpac
packadd cfilter

if !exists('*minpac#init')
  finish
endif

call minpac#init()
call minpac#add('tpope/vim-commentary')
call minpac#add('tpope/vim-eunuch')
call minpac#add('tpope/vim-fugitive')
call minpac#add('tpope/vim-repeat')
call minpac#add('tpope/vim-surround')
call minpac#add('tpope/vim-unimpaired')
call minpac#add('wellle/targets.vim')
call minpac#add('romainl/vim-qf')
call minpac#add('sheerun/vim-polyglot')

command! PackUpdate packadd minpac | source $MYVIMRC | redraw | call minpac#update()
command! PackClean  packadd minpac | source $MYVIMRC | call minpac#clean()
command! PackStatus packadd minpac | source $MYVIMRC | call minpac#status()

syntax on
colorscheme bruin
filetype plugin indent on

let &fillchars='vert: ,fold:·'
let &listchars='tab:| ,eol:¬,trail:⣿,extends:→,precedes:←'
let mapleader = "\<Space>"
set autoindent
set backspace=indent,eol,start
set clipboard=unnamed
set complete+=d
set directory^=$HOME/.vim/tmp//
set foldmethod=indent
set hidden
set hlsearch
set ignorecase
set incsearch
set infercase
set mouse=a
set nobackup
set noswapfile
set number
set path& | let &path .= "**"
set ruler
set smartcase
set tags=./tags;,tags;
set termguicolors
set wildcharm=<C-z>
set wildmenu
set wildmode=full

if executable('rg')
  set grepprg=rg\ --vimgrep
endif

function! Grep(args)
  let args = split(a:args, ' ')
  return system(join([&grepprg, shellescape(args[0], get(args, 1, ''))], ' '))
endfunction
command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<q-args>)
command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<q-args>)

" gq wrapper that tries its best at keeping the cursor in place
function! Format(type, ...)
    normal! '[v']gq
    call winrestview(b:gqview)
    unlet b:gqview
endfunction
nmap <silent> GQ :let b:gqview = winsaveview()<CR>:set opfunc=Format<CR>g@

command! Maximize :exe "normal! <C-w>\|<C-W>_"
command! Minimize :exe "normal! <C-W>="
function! ToggleMaximizeWindow()
    if !exists('b:window_maximized')
        let b:window_maximized = 0
    endif
    if b:window_maximized
        Minimize
        let b:window_maximized = 0
    else
        Maximize
        let b:window_maximized = 1
    endif
endfunction
nnoremap <leader>wm :call ToggleMaximizeWindow()<CR>

:nmap ; :
xnoremap ; :
inoremap kj <Esc>

" Jumps
nnoremap ' `

" Window management
nnoremap <silent> <Leader>wd :silent close<CR>
nnoremap <silent> <Leader>w- :silent sp<CR>
nnoremap <silent> <Leader>w/ :silent vsp<CR>
nnoremap <silent> <Leader>wh :silent wincmd h<CR>
nnoremap <silent> <Leader>wj :silent wincmd j<CR>
nnoremap <silent> <Leader>wk :silent wincmd k<CR>
nnoremap <silent> <Leader>wl :silent wincmd l<CR>

" Buffers
nnoremap <silent> <Leader><Leader> :bp<CR>
nnoremap <silent> <Tab> :bn<CR>

" Easier line indenting
nmap > >>
nmap < <<
xnoremap > >>
xnoremap < <<

" Tab through search results
cnoremap <expr> <Tab>   getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>/<C-r>/" : "<C-z>"
cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>?<C-r>/" : "<S-Tab>"

nnoremap <Leader>/ :Grep<Space>
nnoremap <Leader>* :Grep <C-R>=expand("<cword>")<CR><CR>

" plugin mappings
nmap <Leader>qf <Plug>(qf_qf_toggle)
nmap <Leader>qs <Plug>(qf_qf_switch)
let g:qf_mapping_ack_style = 1

command! -range GB echo join(systemlist("git blame -L <line1>,<line2> " . expand('%')), "\n")
